[
 {
  "file": "/Users/naoyashiga/Desktop/code/iOS/myProduct/BlogReader/BlogReader/json.swift",
  "offset": 1436,
  "remove": 12215,
  "text": "\n        do {\n            obj = try NSJSONSerialization.JSONObjectWithData(\n                        data, options:[])\n        } catch let error as NSError {\n            err = error\n            obj = nil\n        }\n        self.init(err != nil ? err! : obj!)\n    }\n    /// constructs JSON object from string\n    public convenience init(string:String) {\n        let enc:NSStringEncoding = NSUTF8StringEncoding\n        self.init(data: string.dataUsingEncoding(enc)!)\n    }\n    /// parses string to the JSON object\n    /// same as JSON(string:String)\n    public class func parse(string:String)->JSON {\n        return JSON(string:string)\n    }\n    /// constructs JSON object from the content of NSURL\n    public convenience init(nsurl:NSURL) {\n        var enc:NSStringEncoding = NSUTF8StringEncoding\n        let err:NSError?\n        let str =\n        String(try! NSString(\n            contentsOfURL:nsurl, usedEncoding:&enc))\n        if err != nil { self.init(err!) }\n        else { self.init(string:str) }\n    }\n    /// fetch the JSON string from NSURL and parse it\n    /// same as JSON(nsurl:NSURL)\n    public class func fromNSURL(nsurl:NSURL) -> JSON {\n        return JSON(nsurl:nsurl)\n    }\n    /// constructs JSON object from the content of URL\n    public convenience init(url:String) {\n        if let nsurl = NSURL(string:url) as NSURL? {\n            self.init(nsurl:nsurl)\n        } else {\n            self.init(NSError(\n                domain:\"JSONErrorDomain\",\n                code:400,\n                userInfo:[NSLocalizedDescriptionKey: \"malformed URL\"]\n                )\n            )\n        }\n    }\n    /// fetch the JSON string from URL in the string\n    public class func fromURL(url:String) -> JSON {\n        return JSON(url:url)\n    }\n    /// does what JSON.stringify in ES5 does.\n    /// when the 2nd argument is set to true it pretty prints\n    public class func stringify(obj:AnyObject, pretty:Bool=false) -> String! {\n        if !NSJSONSerialization.isValidJSONObject(obj) {\n            JSON(NSError(\n                domain:\"JSONErrorDomain\",\n                code:422,\n                userInfo:[NSLocalizedDescriptionKey: \"not an JSON object\"]\n                ))\n            return nil\n        }\n        return JSON(obj).toString(pretty)\n    }\n}\n/// instance properties\nextension JSON {\n    /// access the element like array\n    public subscript(idx:Int) -> JSON {\n        switch _value {\n        case let err as NSError:\n            return self\n        case let ary as NSArray:\n            if 0 <= idx && idx < ary.count {\n                return JSON(ary[idx])\n            }\n            return JSON(NSError(\n                domain:\"JSONErrorDomain\", code:404, userInfo:[\n                    NSLocalizedDescriptionKey:\n                    \"[\\(idx)] is out of range\"\n                ]))\n        default:\n            return JSON(NSError(\n                domain:\"JSONErrorDomain\", code:500, userInfo:[\n                    NSLocalizedDescriptionKey: \"not an array\"\n                ]))\n            }\n    }\n    /// access the element like dictionary\n    public subscript(key:String)->JSON {\n        switch _value {\n        case let err as NSError:\n            return self\n        case let dic as NSDictionary:\n            if let val:AnyObject = dic[key] { return JSON(val) }\n            return JSON(NSError(\n                domain:\"JSONErrorDomain\", code:404, userInfo:[\n                    NSLocalizedDescriptionKey:\n                    \"[\\\"\\(key)\\\"] not found\"\n                ]))\n        default:\n            return JSON(NSError(\n                domain:\"JSONErrorDomain\", code:500, userInfo:[\n                    NSLocalizedDescriptionKey: \"not an object\"\n                ]))\n            }\n    }\n    /// access json data object\n    public var data:AnyObject? {\n        return self.isError ? nil : self._value\n    }\n    /// Gives the type name as string.\n    /// e.g.  if it returns \"Double\"\n    ///       .asDouble returns Double\n    public var type:String {\n    switch _value {\n    case is NSError:        return \"NSError\"\n    case is NSNull:         return \"NSNull\"\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":              return \"Bool\"\n        case \"q\", \"l\", \"i\", \"s\":    return \"Int\"\n        case \"Q\", \"L\", \"I\", \"S\":    return \"UInt\"\n        default:                    return \"Double\"\n        }\n    case is NSString:               return \"String\"\n    case is NSArray:                return \"Array\"\n    case is NSDictionary:           return \"Dictionary\"\n    default:                        return \"NSError\"\n        }\n    }\n    /// check if self is NSError\n    public var isError:      Bool { return _value is NSError }\n    /// check if self is NSNull\n    public var isNull:       Bool { return _value is NSNull }\n    /// check if self is Bool\n    public var isBool:       Bool { return type == \"Bool\" }\n    /// check if self is Int\n    public var isInt:        Bool { return type == \"Int\" }\n    /// check if self is UInt\n    public var isUInt:       Bool { return type == \"UInt\" }\n    /// check if self is Double\n    public var isDouble:     Bool { return type == \"Double\" }\n    /// check if self is any type of number\n    public var isNumber:     Bool {\n    if let o = _value as? NSNumber {\n        let t = String.fromCString(o.objCType)!\n        return  t != \"c\" && t != \"C\"\n    }\n    return false\n    }\n    /// check if self is String\n    public var isString:     Bool { return _value is NSString }\n    /// check if self is Array\n    public var isArray:      Bool { return _value is NSArray }\n    /// check if self is Dictionary\n    public var isDictionary: Bool { return _value is NSDictionary }\n    /// check if self is a valid leaf node.\n    public var isLeaf:       Bool {\n        return !(isArray || isDictionary || isError)\n    }\n    /// gives NSError if it holds the error. nil otherwise\n    public var asError:NSError? {\n    return _value as? NSError\n    }\n    /// gives NSNull if self holds it. nil otherwise\n    public var asNull:NSNull? {\n    return _value is NSNull ? JSON.null : nil\n    }\n    /// gives Bool if self holds it. nil otherwise\n    public var asBool:Bool? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":  return Bool(o.boolValue)\n        default:\n            return nil\n        }\n    default: return nil\n        }\n    }\n    /// gives Int if self holds it. nil otherwise\n    public var asInt:Int? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":\n            return nil\n        default:\n            return Int(o.longLongValue)\n        }\n    default: return nil\n        }\n    }\n    /// gives Int32 if self holds it. nil otherwise\n    public var asInt32:Int32? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":\n            return nil\n        default:\n            return Int32(o.longLongValue)\n        }\n    default: return nil\n        }\n    }\n    /// gives Int64 if self holds it. nil otherwise\n    public var asInt64:Int64? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":\n            return nil\n        default:\n            return Int64(o.longLongValue)\n        }\n    default: return nil\n        }\n    }\n    /// gives Float if self holds it. nil otherwise\n    public var asFloat:Float? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":\n            return nil\n        default:\n            return Float(o.floatValue)\n        }\n    default: return nil\n        }\n    }\n    /// gives Double if self holds it. nil otherwise\n    public var asDouble:Double? {\n    switch _value {\n    case let o as NSNumber:\n        switch String.fromCString(o.objCType)! {\n        case \"c\", \"C\":\n            return nil\n        default:\n            return Double(o.doubleValue)\n        }\n    default: return nil\n        }\n    }\n    // an alias to asDouble\n    public var asNumber:Double? { return asDouble }\n    /// gives String if self holds it. nil otherwise\n    public var asString:String? {\n    switch _value {\n    case let o as NSString:\n        return o as String\n    default: return nil\n        }\n    }\n    /// if self holds NSArray, gives a [JSON]\n    /// with elements therein. nil otherwise\n    public var asArray:[JSON]? {\n    switch _value {\n    case let o as NSArray:\n        var result = [JSON]()\n        for v:AnyObject in o { result.append(JSON(v)) }\n        return result\n    default:\n        return nil\n        }\n    }\n    /// if self holds NSDictionary, gives a [String:JSON]\n    /// with elements therein. nil otherwise\n    public var asDictionary:[String:JSON]? {\n    switch _value {\n    case let o as NSDictionary:\n        var result = [String:JSON]()\n        for (ko, v): (AnyObject, AnyObject) in o {\n            if let k = ko as? String {\n                result[k] = JSON(v)\n            }\n        }\n        return result\n    default: return nil\n        }\n    }\n    /// Yields date from string\n    public var asDate:NSDate? {\n        if let dateString = _value as? String {\n            let dateFormatter = NSDateFormatter()\n            dateFormatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ssZZZZ\"\n            return dateFormatter.dateFromString(dateString)\n        }\n        return nil\n    }\n    /// gives the number of elements if an array or a dictionary.\n    /// you can use this to check if you can iterate.\n    public var length:Int {\n    switch _value {\n    case let o as NSArray:      return o.count\n    case let o as NSDictionary: return o.count\n    default: return 0\n        }\n    }\n    // gives all values content in JSON object.\n    public var allValues:JSON{\n        if(self._value.allValues == nil) {\n            return JSON([])\n        }\n        return JSON(self._value.allValues)\n    }\n    // gives all keys content in JSON object.\n    public var allKeys:JSON{\n        if(self._value.allKeys == nil) {\n            return JSON([])\n        }\n        return JSON(self._value.allKeys)\n    }\n}\nextension JSON : SequenceType {\n    public func generate()->AnyGenerator<(AnyObject,JSON)> {\n        switch _value {\n        case let o as NSArray:\n            var i = -1\n            return anyGenerator {\n                if ++i == o.count { return nil }\n                return (i, JSON(o[i]))\n            }\n        case let o as NSDictionary:\n            var ks = Array(o.allKeys.reverse())\n            return anyGenerator {\n                if ks.isEmpty { return nil }\n                if let k = ks.removeLast() as? String {\n                    return (k, JSON(o.valueForKey(k)!))\n                } else {\n                    return nil\n                }\n            }\n        default:\n            return anyGenerator{ nil }\n        }\n    }\n    public func mutableCopyOfTheObject() -> AnyObject {\n        return _value.mutableCopy()\n    }\n}\nextension JSON : CustomStringConvertible {\n    /// stringifies self.\n    /// if pretty:true it pretty prints\n    public func toString(pretty:Bool=false)->String {\n        switch _value {\n        case is NSError: return \"\\(_value)\"\n        case is NSNull: return \"null\"\n        case let o as NSNumber:\n            switch String.fromCString(o.objCType)! {\n            case \"c\", \"C\":\n                return o.boolValue.description\n            case \"q\", \"l\", \"i\", \"s\":\n                return o.longLongValue.description\n            case \"Q\", \"L\", \"I\", \"S\":\n                return o.unsignedLongLongValue.description\n            default:\n                switch o.doubleValue {\n                case 0.0/0.0:   return \"0.0/0.0\"    // NaN\n                case -1.0/0.0:  return \"-1.0/0.0\"   // -infinity\n                case +1.0/0.0:  return \"+1.0/0.0\"   //  infinity\n                default:\n                    return o.doubleValue.description\n                }\n            }\n        case let o as NSString:\n            return o.debugDescription\n        default:\n            let opts = pretty\n                ? NSJSONWritingOptions.PrettyPrinted : nil\n            if let data = (try? NSJSONSerialization.dataWithJSONObject(\n                _value, options:opts)",
 }
]
