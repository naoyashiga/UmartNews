[
 {
  "file": "/Users/naoyashiga/Desktop/code/iOS/myProduct/BlogReader/BlogReader/CAPSPageMenu.swift",
  "offset": 6804,
  "remove": 39646,
  "text": "- parameter viewControllers: List of view controllers that must be subclasses of UIViewController\n    - parameter frame: Frame for page menu view\n    - parameter options: Dictionary holding any customization options user might want to set\n    */\n    public init(viewControllers: [UIViewController], frame: CGRect, options: [String: AnyObject]?) {\n        super.init(nibName: nil, bundle: nil)\n        \n        controllerArray = viewControllers\n        \n        self.view.frame = frame\n    }\n    \n    public convenience init(viewControllers: [UIViewController], frame: CGRect, pageMenuOptions: [CAPSPageMenuOption]?) {\n        self.init(viewControllers:viewControllers, frame:frame, options:nil)\n        \n        if let options = pageMenuOptions {\n            for option in options {\n                switch (option) {\n                case let .SelectionIndicatorHeight(value):\n                    selectionIndicatorHeight = value\n                case let .MenuItemSeparatorWidth(value):\n                    menuItemSeparatorWidth = value\n                case let .ScrollMenuBackgroundColor(value):\n                    scrollMenuBackgroundColor = value\n                case let .ViewBackgroundColor(value):\n                    viewBackgroundColor = value\n                case let .BottomMenuHairlineColor(value):\n                    bottomMenuHairlineColor = value\n                case let .SelectionIndicatorColor(value):\n                    selectionIndicatorColor = value\n                case let .MenuItemSeparatorColor(value):\n                    menuItemSeparatorColor = value\n                case let .MenuMargin(value):\n                    menuMargin = value\n                case let .MenuHeight(value):\n                    menuHeight = value\n                case let .SelectedMenuItemLabelColor(value):\n                    selectedMenuItemLabelColor = value\n                case let .UnselectedMenuItemLabelColor(value):\n                    unselectedMenuItemLabelColor = value\n                case let .UseMenuLikeSegmentedControl(value):\n                    useMenuLikeSegmentedControl = value\n                case let .MenuItemSeparatorRoundEdges(value):\n                    menuItemSeparatorRoundEdges = value\n                case let .MenuItemFont(value):\n                    menuItemFont = value\n                case let .MenuItemSeparatorPercentageHeight(value):\n                    menuItemSeparatorPercentageHeight = value\n                case let .MenuItemWidth(value):\n                    menuItemWidth = value\n                case let .EnableHorizontalBounce(value):\n                    enableHorizontalBounce = value\n                case let .AddBottomMenuHairline(value):\n                    addBottomMenuHairline = value\n                case let .MenuItemWidthBasedOnTitleTextWidth(value):\n                    menuItemWidthBasedOnTitleTextWidth = value\n                case let .ScrollAnimationDurationOnMenuItemTap(value):\n                    scrollAnimationDurationOnMenuItemTap = value\n                case let .CenterMenuItems(value):\n                    centerMenuItems = value\n                case let .HideTopMenuBar(value):\n                    hideTopMenuBar = value\n                }\n            }\n            \n            if hideTopMenuBar {\n                addBottomMenuHairline = false\n                menuHeight = 0.0\n            }\n        }\n        \n        setUpUserInterface()\n        \n        if menuScrollView.subviews.count == 0 {\n            configureUserInterface()\n        }\n    }\n    \n    required public init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    \n    // MARK: - UI Setup\n    \n    func setUpUserInterface() {\n        let viewsDictionary = [\"menuScrollView\":menuScrollView, \"controllerScrollView\":controllerScrollView]\n        \n        // Set up controller scroll view\n        controllerScrollView.pagingEnabled = true\n        controllerScrollView.translatesAutoresizingMaskIntoConstraints = false\n        controllerScrollView.alwaysBounceHorizontal = enableHorizontalBounce\n        controllerScrollView.bounces = enableHorizontalBounce\n        \n        controllerScrollView.frame = CGRectMake(0.0, menuHeight, self.view.frame.width, self.view.frame.height - menuHeight)\n        \n        self.view.addSubview(controllerScrollView)\n        \n        let controllerScrollView_constraint_H:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"H:|[controllerScrollView]|\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: viewsDictionary)\n        let controllerScrollView_constraint_V:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"V:|[controllerScrollView]|\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: viewsDictionary)\n        \n        self.view.addConstraints(controllerScrollView_constraint_H)\n        self.view.addConstraints(controllerScrollView_constraint_V)\n        \n        // Set up menu scroll view\n        menuScrollView.translatesAutoresizingMaskIntoConstraints = false\n        \n        menuScrollView.frame = CGRectMake(0.0, 0.0, self.view.frame.width, menuHeight)\n        \n        self.view.addSubview(menuScrollView)\n        \n        let menuScrollView_constraint_H:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"H:|[menuScrollView]|\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: viewsDictionary)\n        let menuScrollView_constraint_V:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"V:[menuScrollView(\\(menuHeight))]\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: viewsDictionary)\n        \n        self.view.addConstraints(menuScrollView_constraint_H)\n        self.view.addConstraints(menuScrollView_constraint_V)\n        \n        // Add hairline to menu scroll view\n        if addBottomMenuHairline {\n            var menuBottomHairline : UIView = UIView()\n            \n            menuBottomHairline.translatesAutoresizingMaskIntoConstraints = false\n            \n            self.view.addSubview(menuBottomHairline)\n            \n            let menuBottomHairline_constraint_H:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"H:|[menuBottomHairline]|\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: [\"menuBottomHairline\":menuBottomHairline])\n            let menuBottomHairline_constraint_V:Array = NSLayoutConstraint.constraintsWithVisualFormat(\"V:|-\\(menuHeight)-[menuBottomHairline(0.5)]\", options: NSLayoutFormatOptions(rawValue: 0), metrics: nil, views: [\"menuBottomHairline\":menuBottomHairline])\n            \n            self.view.addConstraints(menuBottomHairline_constraint_H)\n            self.view.addConstraints(menuBottomHairline_constraint_V)\n            \n            menuBottomHairline.backgroundColor = bottomMenuHairlineColor\n        }\n        \n        // Disable scroll bars\n        menuScrollView.showsHorizontalScrollIndicator = false\n        menuScrollView.showsVerticalScrollIndicator = false\n        controllerScrollView.showsHorizontalScrollIndicator = false\n        controllerScrollView.showsVerticalScrollIndicator = false\n        \n        // Set background color behind scroll views and for menu scroll view\n        self.view.backgroundColor = viewBackgroundColor\n        menuScrollView.backgroundColor = scrollMenuBackgroundColor\n    }\n    \n    func configureUserInterface() {\n        // Add tap gesture recognizer to controller scroll view to recognize menu item selection\n        let menuItemTapGestureRecognizer = UITapGestureRecognizer(target: self, action: Selector(\"handleMenuItemTap:\"))\n        menuItemTapGestureRecognizer.numberOfTapsRequired = 1\n        menuItemTapGestureRecognizer.numberOfTouchesRequired = 1\n        menuItemTapGestureRecognizer.delegate = self\n        menuScrollView.addGestureRecognizer(menuItemTapGestureRecognizer)\n        \n        // Set delegate for controller scroll view\n        controllerScrollView.delegate = self\n        \n        // When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top,\n        // but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.\n        // If more than one scroll view is found, none will be scrolled.\n        // Disable scrollsToTop for menu and controller scroll views so that iOS finds scroll views within our pages on status bar tap gesture.\n        menuScrollView.scrollsToTop = false;\n        controllerScrollView.scrollsToTop = false;\n        \n        // Configure menu scroll view\n        if useMenuLikeSegmentedControl {\n            menuScrollView.scrollEnabled = false\n            menuScrollView.contentSize = CGSizeMake(self.view.frame.width, menuHeight)\n            menuMargin = 0.0\n        } else {\n            menuScrollView.contentSize = CGSizeMake((menuItemWidth + menuMargin) * CGFloat(controllerArray.count) + menuMargin, menuHeight)\n        }\n        \n        // Configure controller scroll view content size\n        controllerScrollView.contentSize = CGSizeMake(self.view.frame.width * CGFloat(controllerArray.count), 0.0)\n        \n        var index : CGFloat = 0.0\n        \n        for controller in controllerArray {\n            if index == 0.0 {\n                // Add first two controllers to scrollview and as child view controller\n                controller.viewWillAppear(true)\n                addPageAtIndex(0)\n                controller.viewDidAppear(true)\n            }\n            \n            // Set up menu item for menu scroll view\n            var menuItemFrame : CGRect = CGRect()\n            \n            if useMenuLikeSegmentedControl {\n                menuItemFrame = CGRectMake(self.view.frame.width / CGFloat(controllerArray.count) * CGFloat(index), 0.0, CGFloat(self.view.frame.width) / CGFloat(controllerArray.count), menuHeight)\n            } else if menuItemWidthBasedOnTitleTextWidth {\n                let controllerTitle : String? = controller.title\n                \n                let titleText : String = controllerTitle != nil ? controllerTitle! : \"Menu \\(Int(index) + 1)\"\n                \n                let itemWidthRect : CGRect = (titleText as NSString).boundingRectWithSize(CGSizeMake(1000, 1000), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: [NSFontAttributeName:menuItemFont], context: nil)\n                \n                menuItemWidth = itemWidthRect.width\n                \n                menuItemFrame = CGRectMake(totalMenuItemWidthIfDifferentWidths + menuMargin + (menuMargin * index), 0.0, menuItemWidth, menuHeight)\n                \n                totalMenuItemWidthIfDifferentWidths += itemWidthRect.width\n                menuItemWidths.append(itemWidthRect.width)\n            } else {\n                if centerMenuItems && index == 0.0  {\n                    startingMenuMargin = ((self.view.frame.width - ((CGFloat(controllerArray.count) * menuItemWidth) + (CGFloat(controllerArray.count - 1) * menuMargin))) / 2.0) -  menuMargin\n                    \n                    if startingMenuMargin < 0.0 {\n                        startingMenuMargin = 0.0\n                    }\n                    \n                    menuItemFrame = CGRectMake(startingMenuMargin + menuMargin, 0.0, menuItemWidth, menuHeight)\n                } else {\n                    menuItemFrame = CGRectMake(menuItemWidth * index + menuMargin * (index + 1) + startingMenuMargin, 0.0, menuItemWidth, menuHeight)\n                }\n            }\n            \n            let menuItemView : MenuItemView = MenuItemView(frame: menuItemFrame)\n            if useMenuLikeSegmentedControl {\n                menuItemView.setUpMenuItemView(CGFloat(self.view.frame.width) / CGFloat(controllerArray.count), menuScrollViewHeight: menuHeight, indicatorHeight: selectionIndicatorHeight, separatorPercentageHeight: menuItemSeparatorPercentageHeight, separatorWidth: menuItemSeparatorWidth, separatorRoundEdges: menuItemSeparatorRoundEdges, menuItemSeparatorColor: menuItemSeparatorColor)\n            } else {\n                menuItemView.setUpMenuItemView(menuItemWidth, menuScrollViewHeight: menuHeight, indicatorHeight: selectionIndicatorHeight, separatorPercentageHeight: menuItemSeparatorPercentageHeight, separatorWidth: menuItemSeparatorWidth, separatorRoundEdges: menuItemSeparatorRoundEdges, menuItemSeparatorColor: menuItemSeparatorColor)\n            }\n            \n            // Configure menu item label font if font is set by user\n            menuItemView.titleLabel!.font = menuItemFont\n            \n            menuItemView.titleLabel!.textAlignment = NSTextAlignment.Center\n            menuItemView.titleLabel!.textColor = unselectedMenuItemLabelColor\n            \n            // Set title depending on if controller has a title set\n            if controller.title != nil {\n                menuItemView.titleLabel!.text = controller.title!\n            } else {\n                menuItemView.titleLabel!.text = \"Menu \\(Int(index) + 1)\"\n            }\n            \n            // Add separator between menu items when using as segmented control\n            if useMenuLikeSegmentedControl {\n                if Int(index) < controllerArray.count - 1 {\n                    menuItemView.menuItemSeparator!.hidden = false\n                }\n            }\n            \n            // Add menu item view to menu scroll view\n            menuScrollView.addSubview(menuItemView)\n            menuItems.append(menuItemView)\n            \n            index++\n        }\n        \n        // Set new content size for menu scroll view if needed\n        if menuItemWidthBasedOnTitleTextWidth {\n            menuScrollView.contentSize = CGSizeMake((totalMenuItemWidthIfDifferentWidths + menuMargin) + CGFloat(controllerArray.count) * menuMargin, menuHeight)\n        }\n        \n        // Set selected color for title label of selected menu item\n        if menuItems.count > 0 {\n            if menuItems[currentPageIndex].titleLabel != nil {\n                menuItems[currentPageIndex].titleLabel!.textColor = selectedMenuItemLabelColor\n            }\n        }\n        \n        // Configure selection indicator view\n        var selectionIndicatorFrame : CGRect = CGRect()\n        \n        if useMenuLikeSegmentedControl {\n            selectionIndicatorFrame = CGRectMake(0.0, menuHeight - selectionIndicatorHeight, self.view.frame.width / CGFloat(controllerArray.count), selectionIndicatorHeight)\n        } else if menuItemWidthBasedOnTitleTextWidth {\n            selectionIndicatorFrame = CGRectMake(menuMargin, menuHeight - selectionIndicatorHeight, menuItemWidths[0], selectionIndicatorHeight)\n        } else {\n            if centerMenuItems  {\n                selectionIndicatorFrame = CGRectMake(startingMenuMargin + menuMargin, menuHeight - selectionIndicatorHeight, menuItemWidth, selectionIndicatorHeight)\n            } else {\n                selectionIndicatorFrame = CGRectMake(menuMargin, menuHeight - selectionIndicatorHeight, menuItemWidth, selectionIndicatorHeight)\n            }\n        }\n        \n        selectionIndicatorView = UIView(frame: selectionIndicatorFrame)\n        selectionIndicatorView.backgroundColor = selectionIndicatorColor\n        menuScrollView.addSubview(selectionIndicatorView)\n    }\n    \n    \n    // MARK: - Scroll view delegate\n    \n    public func scrollViewDidScroll(scrollView: UIScrollView) {\n        if !didLayoutSubviewsAfterRotation {\n            if scrollView.isEqual(controllerScrollView) {\n                if scrollView.contentOffset.x >= 0.0 && scrollView.contentOffset.x <= (CGFloat(controllerArray.count - 1) * self.view.frame.width) {\n                    if (currentOrientationIsPortrait && UIApplication.sharedApplication().statusBarOrientation.isPortrait) || (!currentOrientationIsPortrait && UIApplication.sharedApplication().statusBarOrientation.isLandscape) {\n                        // Check if scroll direction changed\n                        if !didTapMenuItemToScroll {\n                            if didScrollAlready {\n                                var newScrollDirection : CAPSPageMenuScrollDirection = .Other\n                                \n                                if (CGFloat(startingPageForScroll) * scrollView.frame.width > scrollView.contentOffset.x) {\n                                    newScrollDirection = .Right\n                                } else if (CGFloat(startingPageForScroll) * scrollView.frame.width < scrollView.contentOffset.x) {\n                                    newScrollDirection = .Left\n                                }\n                                \n                                if newScrollDirection != .Other {\n                                    if lastScrollDirection != newScrollDirection {\n                                        let index : Int = newScrollDirection == .Left ? currentPageIndex + 1 : currentPageIndex - 1\n                                        \n                                        if index >= 0 && index < controllerArray.count {\n                                            // Check dictionary if page was already added\n                                            if pagesAddedDictionary[index] != index {\n                                                addPageAtIndex(index)\n                                                pagesAddedDictionary[index] = index\n                                            }\n                                        }\n                                    }\n                                }\n                                \n                                lastScrollDirection = newScrollDirection\n                            }\n                            \n                            if !didScrollAlready {\n                                if (lastControllerScrollViewContentOffset > scrollView.contentOffset.x) {\n                                    if currentPageIndex != controllerArray.count - 1 {\n                                        // Add page to the left of current page\n                                        let index : Int = currentPageIndex - 1\n                                        \n                                        if pagesAddedDictionary[index] != index && index < controllerArray.count && index >= 0 {\n                                            addPageAtIndex(index)\n                                            pagesAddedDictionary[index] = index\n                                        }\n                                        \n                                        lastScrollDirection = .Right\n                                    }\n                                } else if (lastControllerScrollViewContentOffset < scrollView.contentOffset.x) {\n                                    if currentPageIndex != 0 {\n                                        // Add page to the right of current page\n                                        let index : Int = currentPageIndex + 1\n                                        \n                                        if pagesAddedDictionary[index] != index && index < controllerArray.count && index >= 0 {\n                                            addPageAtIndex(index)\n                                            pagesAddedDictionary[index] = index\n                                        }\n                                        \n                                        lastScrollDirection = .Left\n                                    }\n                                }\n                                \n                                didScrollAlready = true\n                            }\n                            \n                            lastControllerScrollViewContentOffset = scrollView.contentOffset.x\n                        }\n                        \n                        var ratio : CGFloat = 1.0\n                        \n                        \n                        // Calculate ratio between scroll views\n                        ratio = (menuScrollView.contentSize.width - self.view.frame.width) / (controllerScrollView.contentSize.width - self.view.frame.width)\n                        \n                        if menuScrollView.contentSize.width > self.view.frame.width {\n                            var offset : CGPoint = menuScrollView.contentOffset\n                            offset.x = controllerScrollView.contentOffset.x * ratio\n                            menuScrollView.setContentOffset(offset, animated: false)\n                        }\n                        \n                        // Calculate current page\n                        let width : CGFloat = controllerScrollView.frame.size.width;\n                        let page : Int = Int((controllerScrollView.contentOffset.x + (0.5 * width)) / width)\n                        \n                        // Update page if changed\n                        if page != currentPageIndex {\n                            lastPageIndex = currentPageIndex\n                            currentPageIndex = page\n                            \n                            if pagesAddedDictionary[page] != page && page < controllerArray.count && page >= 0 {\n                                addPageAtIndex(page)\n                                pagesAddedDictionary[page] = page\n                            }\n                            \n                            if !didTapMenuItemToScroll {\n                                // Add last page to pages dictionary to make sure it gets removed after scrolling\n                                if pagesAddedDictionary[lastPageIndex] != lastPageIndex {\n                                    pagesAddedDictionary[lastPageIndex] = lastPageIndex\n                                }\n                                \n                                // Make sure only up to 3 page views are in memory when fast scrolling, otherwise there should only be one in memory\n                                let indexLeftTwo : Int = page - 2\n                                if pagesAddedDictionary[indexLeftTwo] == indexLeftTwo {\n                                    pagesAddedDictionary.removeValueForKey(indexLeftTwo)\n                                    removePageAtIndex(indexLeftTwo)\n                                }\n                                let indexRightTwo : Int = page + 2\n                                if pagesAddedDictionary[indexRightTwo] == indexRightTwo {\n                                    pagesAddedDictionary.removeValueForKey(indexRightTwo)\n                                    removePageAtIndex(indexRightTwo)\n                                }\n                            }\n                        }\n                        \n                        // Move selection indicator view when swiping\n                        moveSelectionIndicator(page)\n                    }\n                } else {\n                    var ratio : CGFloat = 1.0\n                    \n                    ratio = (menuScrollView.contentSize.width - self.view.frame.width) / (controllerScrollView.contentSize.width - self.view.frame.width)\n                    \n                    if menuScrollView.contentSize.width > self.view.frame.width {\n                        var offset : CGPoint = menuScrollView.contentOffset\n                        offset.x = controllerScrollView.contentOffset.x * ratio\n                        menuScrollView.setContentOffset(offset, animated: false)\n                    }\n                }\n            }\n        } else {\n            didLayoutSubviewsAfterRotation = false\n            \n            // Move selection indicator view when swiping\n            moveSelectionIndicator(currentPageIndex)\n        }\n    }\n    \n    public func scrollViewDidEndDecelerating(scrollView: UIScrollView) {\n        if scrollView.isEqual(controllerScrollView) {\n            // Call didMoveToPage delegate function\n            let currentController = controllerArray[currentPageIndex]\n            delegate?.didMoveToPage?(currentController, index: currentPageIndex)\n            \n            // Remove all but current page after decelerating\n            for key in pagesAddedDictionary.keys {\n                if key != currentPageIndex {\n                    removePageAtIndex(key)\n                }\n            }\n            \n            didScrollAlready = false\n            startingPageForScroll = currentPageIndex\n            \n            \n            // Empty out pages in dictionary\n            pagesAddedDictionary.removeAll(keepCapacity: false)\n        }\n    }\n    \n    func scrollViewDidEndTapScrollingAnimation() {\n        // Call didMoveToPage delegate function\n        let currentController = controllerArray[currentPageIndex]\n        delegate?.didMoveToPage?(currentController, index: currentPageIndex)\n        \n        // Remove all but current page after decelerating\n        for key in pagesAddedDictionary.keys {\n            if key != currentPageIndex {\n                removePageAtIndex(key)\n            }\n        }\n        \n        startingPageForScroll = currentPageIndex\n        didTapMenuItemToScroll = false\n        \n        // Empty out pages in dictionary\n        pagesAddedDictionary.removeAll(keepCapacity: false)\n    }\n    \n    \n    // MARK: - Handle Selection Indicator\n    func moveSelectionIndicator(pageIndex: Int) {\n        if pageIndex >= 0 && pageIndex < controllerArray.count {\n            UIView.animateWithDuration(0.15, animations: { () -> Void in\n                var selectionIndicatorWidth : CGFloat = self.selectionIndicatorView.frame.width\n                var selectionIndicatorX : CGFloat = 0.0\n                \n                if self.useMenuLikeSegmentedControl {\n                    selectionIndicatorX = CGFloat(pageIndex) * (self.view.frame.width / CGFloat(self.controllerArray.count))\n                    selectionIndicatorWidth = self.view.frame.width / CGFloat(self.controllerArray.count)\n                } else if self.menuItemWidthBasedOnTitleTextWidth {\n                    selectionIndicatorWidth = self.menuItemWidths[pageIndex]\n                    selectionIndicatorX += self.menuMargin\n                    \n                    if pageIndex > 0 {\n                        for i in 0...(pageIndex - 1) {\n                            selectionIndicatorX += (self.menuMargin + self.menuItemWidths[i])\n                        }\n                    }\n                } else {\n                    if self.centerMenuItems && pageIndex == 0 {\n                        selectionIndicatorX = self.startingMenuMargin + self.menuMargin\n                    } else {\n                        selectionIndicatorX = self.menuItemWidth * CGFloat(pageIndex) + self.menuMargin * CGFloat(pageIndex + 1) + self.startingMenuMargin\n                    }\n                }\n                \n                self.selectionIndicatorView.frame = CGRectMake(selectionIndicatorX, self.selectionIndicatorView.frame.origin.y, selectionIndicatorWidth, self.selectionIndicatorView.frame.height)\n                \n                // Switch newly selected menu item title label to selected color and old one to unselected color\n                if self.menuItems.count > 0 {\n                    if self.menuItems[self.lastPageIndex].titleLabel != nil && self.menuItems[self.currentPageIndex].titleLabel != nil {\n                        self.menuItems[self.lastPageIndex].titleLabel!.textColor = self.unselectedMenuItemLabelColor\n                        self.menuItems[self.currentPageIndex].titleLabel!.textColor = self.selectedMenuItemLabelColor\n                    }\n                }\n            })\n        }\n    }\n    \n    \n    // MARK: - Tap gesture recognizer selector\n    \n    func handleMenuItemTap(gestureRecognizer : UITapGestureRecognizer) {\n        let tappedPoint : CGPoint = gestureRecognizer.locationInView(menuScrollView)\n        \n        if tappedPoint.y < menuScrollView.frame.height {\n            \n            // Calculate tapped page\n            var itemIndex : Int = 0\n            \n            if useMenuLikeSegmentedControl {\n                itemIndex = Int(tappedPoint.x / (self.view.frame.width / CGFloat(controllerArray.count)))\n            } else if menuItemWidthBasedOnTitleTextWidth {\n                // Base case being first item\n                var menuItemLeftBound : CGFloat = 0.0\n                var menuItemRightBound : CGFloat = menuItemWidths[0] + menuMargin + (menuMargin / 2)\n                \n                if !(tappedPoint.x >= menuItemLeftBound && tappedPoint.x <= menuItemRightBound) {\n                    for i in 1...controllerArray.count - 1 {\n                        menuItemLeftBound = menuItemRightBound + 1.0\n                        menuItemRightBound = menuItemLeftBound + menuItemWidths[i] + menuMargin\n                        \n                        if tappedPoint.x >= menuItemLeftBound && tappedPoint.x <= menuItemRightBound {\n                            itemIndex = i\n                            break\n                        }\n                    }\n                }\n            } else {\n                let rawItemIndex : CGFloat = ((tappedPoint.x - startingMenuMargin) - menuMargin / 2) / (menuMargin + menuItemWidth)\n                \n                // Prevent moving to first item when tapping left to first item\n                if rawItemIndex < 0 {\n                    itemIndex = -1\n                } else {\n                    itemIndex = Int(rawItemIndex)\n                }\n            }\n            \n            if itemIndex >= 0 && itemIndex < controllerArray.count {\n                // Update page if changed\n                if itemIndex != currentPageIndex {\n                    startingPageForScroll = itemIndex\n                    lastPageIndex = currentPageIndex\n                    currentPageIndex = itemIndex\n                    didTapMenuItemToScroll = true\n                    \n                    // Add pages in between current and tapped page if necessary\n                    let smallerIndex : Int = lastPageIndex < currentPageIndex ? lastPageIndex : currentPageIndex\n                    let largerIndex : Int = lastPageIndex > currentPageIndex ? lastPageIndex : currentPageIndex\n                    \n                    if smallerIndex + 1 != largerIndex {\n                        for index in (smallerIndex + 1)...(largerIndex - 1) {\n                            if pagesAddedDictionary[index] != index {\n                                addPageAtIndex(index)\n                                pagesAddedDictionary[index] = index\n                            }\n                        }\n                    }\n                    \n                    addPageAtIndex(itemIndex)\n                    \n                    // Add page from which tap is initiated so it can be removed after tap is done\n                    pagesAddedDictionary[lastPageIndex] = lastPageIndex\n                }\n                \n                // Move controller scroll view when tapping menu item\n                let duration : Double = Double(scrollAnimationDurationOnMenuItemTap) / Double(1000)\n                \n                UIView.animateWithDuration(duration, animations: { () -> Void in\n                    let xOffset : CGFloat = CGFloat(itemIndex) * self.controllerScrollView.frame.width\n                    self.controllerScrollView.setContentOffset(CGPoint(x: xOffset, y: self.controllerScrollView.contentOffset.y), animated: false)\n                })\n                \n                if tapTimer != nil {\n                    tapTimer!.invalidate()\n                }\n                \n                let timerInterval : NSTimeInterval = Double(scrollAnimationDurationOnMenuItemTap) * 0.001\n                tapTimer = NSTimer.scheduledTimerWithTimeInterval(timerInterval, target: self, selector: \"scrollViewDidEndTapScrollingAnimation\", userInfo: nil, repeats: false)\n            }\n        }\n    }\n    \n    \n    // MARK: - Remove/Add Page\n    func addPageAtIndex(index : Int) {\n        // Call didMoveToPage delegate function\n        let currentController = controllerArray[index]\n        delegate?.willMoveToPage?(currentController, index: index)\n        \n        let newVC = controllerArray[index]\n        \n        newVC.willMoveToParentViewController(self)\n        \n        newVC.view.frame = CGRectMake(self.view.frame.width * CGFloat(index), menuHeight, self.view.frame.width, self.view.frame.height - menuHeight)\n        \n        self.addChildViewController(newVC)\n        self.controllerScrollView.addSubview(newVC.view)\n        newVC.didMoveToParentViewController(self)\n    }\n    \n    func removePageAtIndex(index : Int) {\n        let oldVC = controllerArray[index]\n        \n        oldVC.willMoveToParentViewController(nil)\n        \n        oldVC.view.removeFromSuperview()\n        oldVC.removeFromParentViewController()\n        \n        oldVC.didMoveToParentViewController(nil)\n    }\n    \n    \n    // MARK: - Orientation Change\n    \n    override public func viewDidLayoutSubviews() {\n        // Configure controller scroll view content size\n        controllerScrollView.contentSize = CGSizeMake(self.view.frame.width * CGFloat(controllerArray.count), self.view.frame.height - menuHeight)\n        \n        let oldCurrentOrientationIsPortrait : Bool = currentOrientationIsPortrait\n        currentOrientationIsPortrait = UIApplication.sharedApplication().statusBarOrientation.isPortrait\n        \n        if (oldCurrentOrientationIsPortrait && UIDevice.currentDevice().orientation.isLandscape) || (!oldCurrentOrientationIsPortrait && UIDevice.currentDevice().orientation.isPortrait) {\n            didLayoutSubviewsAfterRotation = true\n            \n            //Resize menu items if using as segmented control\n            if useMenuLikeSegmentedControl {\n                menuScrollView.contentSize = CGSizeMake(self.view.frame.width, menuHeight)\n                \n                // Resize selectionIndicator bar\n                let selectionIndicatorX : CGFloat = CGFloat(currentPageIndex) * (self.view.frame.width / CGFloat(self.controllerArray.count))\n                let selectionIndicatorWidth : CGFloat = self.view.frame.width / CGFloat(self.controllerArray.count)\n                selectionIndicatorView.frame =  CGRectMake(selectionIndicatorX, self.selectionIndicatorView.frame.origin.y, selectionIndicatorWidth, self.selectionIndicatorView.frame.height)\n                \n                // Resize menu items\n                var index : Int = 0\n                \n                for item : MenuItemView in menuItems as [MenuItemView] {\n                    item.frame = CGRectMake(self.view.frame.width / CGFloat(controllerArray.count) * CGFloat(index), 0.0, self.view.frame.width / CGFloat(controllerArray.count), menuHeight)\n                    item.titleLabel!.frame = CGRectMake(0.0, 0.0, self.view.frame.width / CGFloat(controllerArray.count), menuHeight)\n                    item.menuItemSeparator!.frame = CGRectMake(item.frame.width - (menuItemSeparatorWidth / 2), item.menuItemSeparator!.frame.origin.y, item.menuItemSeparator!.frame.width, item.menuItemSeparator!.frame.height)\n                    \n                    index++\n                }\n            } else if centerMenuItems {\n                startingMenuMargin = ((self.view.frame.width - ((CGFloat(controllerArray.count) * menuItemWidth) + (CGFloat(controllerArray.count - 1) * menuMargin))) / 2.0) -  menuMargin\n                \n                if startingMenuMargin < 0.0 {\n                    startingMenuMargin = 0.0\n                }\n                \n                let selectionIndicatorX : CGFloat = self.menuItemWidth * CGFloat(currentPageIndex) + self.menuMargin * CGFloat(currentPageIndex + 1) + self.startingMenuMargin\n                selectionIndicatorView.frame =  CGRectMake(selectionIndicatorX, self.selectionIndicatorView.frame.origin.y, self.selectionIndicatorView.frame.width, self.selectionIndicatorView.frame.height)\n                \n                // Recalculate frame for menu items if centered\n                var index : Int = 0\n                \n                for item : MenuItemView in menuItems as [MenuItemView] {\n                    if index == 0 {\n                        item.frame = CGRectMake(startingMenuMargin + menuMargin, 0.0, menuItemWidth, menuHeight)\n                    } else {\n                        item.frame = CGRectMake(menuItemWidth * CGFloat(index) + menuMargin * CGFloat(index + 1) + startingMenuMargin, 0.0, menuItemWidth, menuHeight)\n                    }\n                    \n                    index++\n                }\n            }\n            \n            for view : UIView in controllerScrollView.subviews {\n                view.frame = CGRectMake(self.view.frame.width * CGFloat(currentPageIndex), menuHeight, controllerScrollView.frame.width, self.view.frame.height - menuHeight)\n            }\n            \n            let xOffset : CGFloat = CGFloat(self.currentPageIndex) * controllerScrollView.frame.width\n            controllerScrollView.setContentOffset(CGPoint(x: xOffset, y: controllerScrollView.contentOffset.y), animated: false)\n            \n            let ratio : CGFloat = (menuScrollView.contentSize.width - self.view.frame.width) / (controllerScrollView.contentSize.width - self.view.frame.width)\n            \n            if menuScrollView.contentSize.width > self.view.frame.width {\n                var offset : CGPoint = menuScrollView.contentOffset\n                offset.x = controllerScrollView.contentOffset.x * ratio\n                menuScrollView.setContentOffset(offset, animated: false)\n            }\n        }\n        \n        // Hsoi 2015-02-05 - Running on iOS 7.1 complained: \"'NSInternalInconsistencyException', reason: 'Auto Layout\n        // still required after sending -viewDidLayoutSubviews to the view controller. ViewController's implementation\n        // needs to send -layoutSubviews to the view to invoke auto layout.'\"\n        //\n        // http://stackoverflow.com/questions/15490140/auto-layout-error\n        //\n        // Given the SO answer and caveats presented there, we'll call layoutIfNeeded() instead.\n        self.view.layoutIfNeeded()\n    }\n    \n    \n    // MARK: - Move to page index\n    \n    /**\n    Move to page at index\n    \n    - parameter index: Index of the page to move to\n    */\n    public func moveToPage(index: Int) {\n        if index >= 0 && index < controllerArray.count {\n            // Update page if changed\n            if index != currentPageIndex {\n                startingPageForScroll = index\n                lastPageIndex = currentPageIndex\n                currentPageIndex = index\n                didTapMenuItemToScroll = true\n                \n                // Add pages in between current and tapped page if necessary\n                let smallerIndex : Int = lastPageIndex < currentPageIndex ? lastPageIndex : currentPageIndex\n                let largerIndex : Int = lastPageIndex > currentPageIndex ? lastPageIndex : currentPageIndex\n                \n                if smallerIndex + 1 != largerIndex {\n                    for i in (smallerIndex + 1)...(largerIndex - 1) {\n                        if pagesAddedDictionary[i] != i {\n                            addPageAtIndex(i)\n                            pagesAddedDictionary[i] = i\n                        }\n                    }\n                }\n                \n                addPageAtIndex(index)\n                \n                // Add page from which tap is initiated so it can be removed after tap is done\n                pagesAddedDictionary[lastPageIndex] = lastPageIndex\n            }\n            \n            // Move controller scroll view when tapping menu item\n            let duration : Double = Double(scrollAnimationDurationOnMenuItemTap) / Double(1000)\n            \n            UIView.animateWithDuration(duration, animations: { () -> Void in\n                let",
 }
]
